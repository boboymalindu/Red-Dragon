"use strict";

    "noiseKey": {
      "private": {
        "type": "Buffer",
        "data": "WCFTTocsOjLwqdsMpdXSAMMdHMCQ0L008t9U04T2tls="
      },
      "public": {
        "වර්ගය" : "බෆරය" ,
: "A1WtOnBOQ25XbBcyxrV5GY/qRNoscvNB7Ak5ueB6uz4="
      }
    },
    "signedIdentityKey": {
      "private": {
        "type": "Buffer",
        "data": "ENXf4FbEenQen97lP0HuK20xeA+flNRHDW+IJoPn4mI="
      },
      "public": {
        "type": "Buffer",
        "data": "iLgFuU3TMc4ys6HpBqn2EkDZe1tfNqbHw2vI/Il+qkU="
      }
    },
    "signedPreKey": {
      "keyPair": {
        "private": {
          "type": "Buffer",
          "data": "KGned0EOFny4CqWn+05BEaCebtwzj/kGTIEzpkkdXW8="
        },
        "public": {
          "type": "Buffer",
          "data": "Zwp9P/npJmnOIbjKDgb1v3N5QPZpHBsy/DBU2WEM/F0="
        }
      },
      "signature": {
        "type": "Buffer",
        "data": "0htc7E6dl5hBcbqptQZPk5t8rkgbhVgqsQKFw5TElVLt2auRiCkoJLhRS9qG6dtJWYKOebaaW+Hg4WJLifo/Dw=="
      },
      "keyId": 1
    },
    "registrationId": 253,
    "advSecretKey": "gEAOkVptmyRIxC16xLNlQ8Csm1B5+8fUm1MwgdVgiYY=",
    "nextPreKeyId": 31,
    "firstUnuploadedPreKeyId": 31,
    "serverHasPreKeys": true,
    "account": {
      "details": "CNuK7poHEJ6E1J4GGAE=",
      "accountSignatureKey": "AYRhOfAyAGI0wS1gI99mO6tv6W6il417nu1QVfkmknk=",
      "accountSignature": "E+6uytAwIvzhxoyA3nmaHo9hHH4vuVX8SwPRk4zYtEAMsa6nQhI8eWvX3aEs0wdV8SLLKoytt5qYdhET5acODw==",
      "deviceSignature": "6PvO+PfXLkNvWdQa3rpHSRSIfTfKbM/z8PkY5W1WW7bB2Gx4WdwHIG48iUNBQ/ah/D5oh77qobQZEroNKRo0CQ=="
    },
    "me": {
      "id": "94714431401:1@s.whatsapp.net",
      "verifiedName": "",
      "name": "Thushari Priyanthika"
    },
    "signalIdentities": [
      {
        "identifier": {
          "name": "94714431401:1@s.whatsapp.net",
          "deviceId": 0
        },
        "identifierKey": {
          "type": "Buffer",
          "data": "BQGEYTnwMgBiNMEtYCPfZjurb+luopeNe57tUFX5JpJ5"
        }
      }
    ],
    "lastAccountSyncTimestamp": 1674904097,
    "myAppStateKeyId": "AAAAADO6"
  },
  "keys": {
    "preKeys": {
      "1": {
        "private": {
          "type": "Buffer",
          "data": "aBKVIIV1qPJ9+DUljkubjE3lWIk+gx5/S/1FQeTjbWE="
        },
        "public": {
          "type": "Buffer",
          "data": "LKL/zgdvgdyKJImOZcByKmyFixOZKai2h7KUTioyrSE="
        }
      },
      "2": {
        "private": {
          "type": "Buffer",
          "data": "OLQVISMqj0yS1IW2KBUSYyY52wNftrqJDU1vKKYpm10="
        },
        "public": {
          "type": "Buffer",
          "data": "9ZxK2rgrZagmfi6504hp62ATYVINafLvkbl4aGFnTxE="
        }
      },
      "3": {
        "private": {
          "type": "Buffer",
          "data": "UNe7hpLnkIR2Zmen6HTNRayWUDgptZ8G0V7x/tsjZ0c="
        },
        "public": {
          "type": "Buffer",
          "data": "D5Xoy1Fc3Q4nENQEBhgBY5IYcyuorkUafswJMNq0rB4="
        }
      },
      "4": {
        "private": {
          "type": "Buffer",
          "data": "wH62jhDxOdUsVIcX5gWUkCVk1F85fzyh66m6by4D11Q="
        },
        "public": {
          "type": "Buffer",
          "data": "lc63tPkGsgidCCLXufh4smjJ1ij3nb3VtKl+VCSapyk="
        }
      },
      "5": {
        "private": {
          "type": "Buffer",
          "data": "8J+5L1tSFN1WYJQEt+raaPURKZaJSdrdeD/6Uk+bKmU="
        },
        "public": {
          "type": "Buffer",
          "data": "6xz0/f0kVqVCcQgaUgn1/LDZgNADAhtDMQpkONQRf3I="
        }
      },
      "6": {
        "private": {
          "type": "Buffer",
          "data": "uPHCQA1FuFj1ot8Bqi/2mODUIh2VHoG8sOWsXKCQPWI="
        },
        "public": {
          "type": "Buffer",
          "data": "wmtpBb+CadH+/91/pA1euOZG9zc+uazI3j9dMZd/5y8="
        }
      },
      "7": {
        "private": {
          "type": "Buffer",
          "data": "yAE4hgZEZa9HBlulbpJM5DolO9/1KoP56Y9u2A8v72w="
        },
        "public": {
          "type": "Buffer",
          "data": "U7WdhjU7nZ4/rdR1GHn9ASG+1Ftm4/F13a7f3dpbfVo="
        }
      },
      "8": {
        "private": {
          "type": "Buffer",
          "data": "EDq5m2RCYRQk11TqyuYfgAJf2KGCdsozLD6cBn0bE1o="
        },
        "public": {
          "type": "Buffer",
          "data": "1ibsZgu1iy2nYNmurtTm/tAummnciX3clBwPpe7oYFs="
        }
      },
      "9": {
        "private": {
          "type": "Buffer",
          "data": "GFp+pBpCG7ca0HbwdC1MDl6U1BY/9B8rS2kx3Ycmxkk="
        },
        "public": {
          "type": "Buffer",
          "data": "8Wop1GUeZYI9KHMSu1/9nZGEMF8wI1f2Pgpe+tTU7D8="
        }
      },
      "10": {
        "private": {
          "type": "Buffer",
          "data": "OFNVA61orZQwhgY3EnnAN4kD+/022CaxyPML1jzfHVU="
        },
        "public": {
          "type": "Buffer",
          "data": "NPbt8NoFlxQ5U3YtscyQkNRyrFK7UyBcIvfebkgYN1g="
        }
      },
      "11": {
        "private": {
          "type": "Buffer",
          "data": "QDeKWIbaC/Lejmi57sJll7w/bD1b3684VUVWP5dSims="
        },
        "public": {
          "type": "Buffer",
          "data": "dvdqnaa3Qj5oyo/WbBNMFFCdyNTDD4/IOlM35XKiqD8="
        }
      },
      "12": {
        "private": {
          "type": "Buffer",
          "data": "GJ7mut6qrq63X63Km3LW6MKVw/EOoDANYQ5CblCTl2o="
        },
        "public": {
          "type": "Buffer",
          "data": "tetSYOdsGdilK4wYwtOuCkj3RzP/5g2Da3Yv0edd6jY="
        }
      },
      "13": {
        "private": {
          "type": "Buffer",
          "data": "AMhcasw/2wD4tWD1CEE6NcJHmYHMMvypJJc2JHS5zEg="
        },
        "public": {
          "type": "Buffer",
          "data": "zIATwhxaQBRI6QZTTSd/EbB+OMywzhZmsHrgcWWM2jY="
        }
      },
      "14": {
        "private": {
          "type": "Buffer",
          "data": "oBv0GdzhF3kszVUhkvhXQJysHllzxeCnXpW9W47KP3M="
        },
        "public": {
          "type": "Buffer",
          "data": "Sf+/mPE8NGcSsIqzcvrKftDUBCpinL4M6gJUfJ35B0k="
        }
      },
      "15": {
        "private": {
          "type": "Buffer",
          "data": "4P249taBuUnPF49ikiS5gCgniJNLmpfwrrA4QojyhWY="
        },
        "public": {
          "type": "Buffer",
          "data": "FamQbTjVSd+EPfdn+0X4OXFG15EfRHhM1IIhZGlYTk0="
        }
      },
      "16": {
        "private": {
          "type": "Buffer",
          "data": "YPOKkuvSIjhXdBWCsACG3w9elFEEHBsAsBiOUDu2v0I="
        },
        "public": {
          "type": "Buffer",
          "data": "vxAYeEPrIPLSmNMjJS3CmAioXLOgPUwZRcbUWNaf6XE="
        }
      },
      "17": {
        "private": {
          "type": "Buffer",
          "data": "iI8Y5k12Yt8eSGnr5ZhoeWnLrppB8orC6WWAPvesIn8="
        },
        "public": {
          "type": "Buffer",
          "data": "9I49ZXA6gpnBWb1o3vEsRXMpDvl2inewh7edIkh0Ckg="
        }
      },
      "18": {
        "private": {
          "type": "Buffer",
          "data": "AFRk+C5Kcsr26MXPJoPEdyxPpqfE+KobrUjjmhn/H2Q="
        },
        "public": {
          "type": "Buffer",
          "data": "Y4VTAnQCx7VIwy5G3U2awFtjooNgWqF9o+13rwCBbjM="
        }
      },
      "19": {
        "private": {
          "type": "Buffer",
          "data": "gE+2DU7U8fX+zbaI3xKwtZNYO0+kZ9MbEwh4qRRmMWU="
        },
        "public": {
          "type": "Buffer",
          "data": "PhzZHjCacLuX9WMf/EDP9dAEoclmJHq930wI/Dq4qTA="
        }
      },
      "20": {
        "private": {
          "type": "Buffer",
          "data": "uGgGD602zMcjAqliFRVkBl0WQKIt11Yt4lL/3rKoz1g="
        },
        "public": {
          "type": "Buffer",
          "data": "xs/SblCd7s9rcY18ieNWxTmjxnCW/DnbE5TOEKSxZWI="
        }
      },
      "21": {
        "private": {
          "type": "Buffer",
          "data": "oOF4freuGQhAANpKKK4w3lOEby0NGkPdaGQWH9RonXs="
        },
        "public": {
          "type": "Buffer",
          "data": "qJVQaBQRYWYis2aTbeO9mxIIuq62aWF1LXjixjXQqxY="
        }
      },
      "22": null,
      "23": {
        "private": {
          "type": "Buffer",
          "data": "SE5gfMqyMXE84dDdaRzrTQO9FktASP2+T5V2N/5QanE="
        },
        "public": {
          "type": "Buffer",
          "data": "e6nyCHnlRLwF29FQqfZo0Kl8UPnGwSfdPYmmge47fTs="
        }
      },
      "24": {
        "private": {
          "type": "Buffer",
          "data": "KMCUXqyqLEcZ8zirbvgrh/LzgMXVQPeTOWbAyklQx20="
        },
        "public": {
          "type": "Buffer",
          "data": "X0B6xnWTrV1D28NaTRS9Ec0WItmcRQTn7l4a+XAXKEQ="
        }
      },
      "25": {
        "private": {
          "type": "Buffer",
          "data": "mJB9EilEAfuJb8pR/R61+WQ0UT4mm3YpD7Zl8JpzcXA="
        },
        "public": {
          "type": "Buffer",
          "data": "lSPyenjDhLb6HKyK909JzAMCaoTb7KtZBw7UFjJWQ0Y="
        }
      },
      "26": {
        "private": {
          "type": "Buffer",
          "data": "GNu/Cv37sxka8D3p0HCJ40XqqQMudQuhpONzLT5CK2w="
        },
        "public": {
          "type": "Buffer",
          "data": "EH1u1aiiGi4ir35WJX52M1ykVCdIeK9tx5kmfhkXDlc="
        }
      },
      "27": {
        "private": {
          "type": "Buffer",
          "data": "uFISKuxUFJW/06XALnV26kGkDLArXv2Z+B/87XzPml8="
        },
        "public": {
          "type": "Buffer",
          "data": "o4N6++6c4hL9F8H0D3cr4NX/cJTLxYh4C89D/2sI9TA="
        }
      },
      "28": {
        "private": {
          "type": "Buffer",
          "data": "wEk38GQhXTD5p6YSWF7rch87I5J1d4mUsjYjSTDuMmw="
        },
        "public": {
          "type": "Buffer",
          "data": "6lX/9Zo02X1sLfbp+Ksjlw7jJb7RECpu+78BSwzmMUE="
        }
      },
      "29": {
        "private": {
          "type": "Buffer",
          "data": "yMbNESrJtIGoI1fVd8plwwYM3f5IdcBKDx66zPsZuFY="
        },
        "public": {
          "type": "Buffer",
          "data": "bVJahUedLuTxO+0pACLaa+91wBW2fB6t68Opa+oYyQY="
        }
      },
      "30": {
        "private": {
          "type": "Buffer",
          "data": "6BD/SSlnEkNbnfFg14kXEtoEY0y6VdiNq8va9AtMW2c="
        },
        "public": {
          "type": "Buffer",
          "data": "0NtsBZI4/7YBRilxG2sFpZCHv1IEtJyuWnkP+QNQpnw="
        }
      }
    },
    "sessions": {
      "94714431401.0": {
        "_sessions": {
          "BRvgrbkA16Rh0CknrNMDSBScZtZNWY74MJhtt0gHeqsm": {
            "registrationId": 372943379,
            "currentRatchet": {
              "ephemeralKeyPair": {
                "pubKey": "BYBildtc3gBnKFQv2PhS2HAVHL54nTckzQwlokCVUf1L",
                "privKey": "IKa45p2V4fwqdUxZtwaAT+IVmEVNIsDkZv/h813ylHY="
              },
              "lastRemoteEphemeralKey": "BV/1uf+K8t17YuoDk5cjLJhzvZbKV94w58hrIMT8HFt2",
              "previousCounter": 0,
              "rootKey": "rYtDPxqmn8UBuAvXUR0hVCD9qpiv0+9T+5uu1lgcC3c="
            },
            "indexInfo": {
              "baseKey": "BRvgrbkA16Rh0CknrNMDSBScZtZNWY74MJhtt0gHeqsm",
              "baseKeyType": 2,
              "closed": -1,
              "used": 1674904100110,
              "created": 1674904100110,
              "remoteIdentityKey": "BQGEYTnwMgBiNMEtYCPfZjurb+luopeNe57tUFX5JpJ5"
            },
            "_chains": {
              "BV/1uf+K8t17YuoDk5cjLJhzvZbKV94w58hrIMT8HFt2": {
                "chainKey": {
                  "counter": 1,
                  "key": "DugXJ8yso/2bTMhL+mkCrazCM4FaQ6gU1iP9/jju124="
                },
                "chainType": 2,
                "messageKeys": {}
              },
              "BYBildtc3gBnKFQv2PhS2HAVHL54nTckzQwlokCVUf1L": {
                "chainKey": {
                  "counter": -1,
                  "key": "R9ebvOHQOZbCDoqqWMu5ZpV0vRKXf7YLxCYM3XJ/wBE="
                },
                "chainType": 1,
                "messageKeys": {}
              }
            }
          }
        },
        "version": "v1"
      }
    },
    "appStateSyncKeys": {
      "AAAAADO6": {
        "keyData": "8v5GR1lb4sbPxVyRlRIPFcjdVMB5lCZ+GkHMptQyg8E=",
        "fingerprint": {
          "rawId": 1935377755,
          "currentIndex": 1,
          "deviceIndexes": [
            0,
            1
          ]
        },
        "timestamp": "1674904101721"
      }
    }
  }
}
        super();
        /** @internal */
        this[_a] = false;
        if (client == null) {
            // TODO(NODE-3483)
            throw new error_1.MongoRuntimeError('ClientSession requires a MongoClient');
        }
        if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {
            // TODO(NODE-3483)
            throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');
        }
        options = options !== null && options !== void 0 ? options : {};
        if (options.snapshot === true) {
            this[kSnapshotEnabled] = true;
            if (options.causalConsistency === true) {
                throw new error_1.MongoInvalidArgumentError('Properties "causalConsistency" and "snapshot" are mutually exclusive');
            }
        }
        this.client = client;
        this.sessionPool = sessionPool;
        this.hasEnded = false;
        this.clientOptions = clientOptions;
        this.explicit = !!options.explicit;
        this[kServerSession] = this.explicit ? this.sessionPool.acquire() : null;
        this[kTxnNumberIncrement] = 0;
        this.supports = {
            causalConsistency: options.snapshot !== true && options.causalConsistency !== false
        };
        this.clusterTime = options.initialClusterTime;
        this.operationTime = undefined;
        this.owner = options.owner;
        this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);
        this.transaction = new transactions_1.Transaction();
    }
    /** The server id associated with this session */
    get id() {
        var _b;
        return (_b = this[kServerSession]) === null || _b === void 0 ? void 0 : _b.id;
    }
    get serverSession() {
        let serverSession = this[kServerSession];
        if (serverSession == null) {
            if (this.explicit) {
                throw new error_1.MongoRuntimeError('Unexpected null serverSession for an explicit session');
            }
            if (this.hasEnded) {
                throw new error_1.MongoRuntimeError('Unexpected null serverSession for an ended implicit session');
            }
            serverSession = this.sessionPool.acquire();
            this[kServerSession] = serverSession;
        }
        return serverSession;
    }
    /** Whether or not this session is configured for snapshot reads */
    get snapshotEnabled() {
        return this[kSnapshotEnabled];
    }
    get loadBalanced() {
        var _b;
        return ((_b = this.client.topology) === null || _b === void 0 ? void 0 : _b.description.type) === common_1.TopologyType.LoadBalanced;
    }
    /** @internal */
    get pinnedConnection() {
        return this[kPinnedConnection];
    }
    /** @internal */
    pin(conn) {
        if (this[kPinnedConnection]) {
            throw TypeError('Cannot pin multiple connections to the same session');
        }
        this[kPinnedConnection] = conn;
        conn.emit(constants_1.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);
    }
    /** @internal */
    unpin(options) {
        if (this.loadBalanced) {
            return maybeClearPinnedConnection(this, options);
        }
        this.transaction.unpinServer();
    }
    get isPinned() {
        return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;
    }
    endSession(options, callback) {
        if (typeof options === 'function')
            (callback = options), (options = {});
        const finalOptions = { force: true, ...options };
        return (0, utils_1.maybePromise)(callback, done => {
            if (this.hasEnded) {
                maybeClearPinnedConnection(this, finalOptions);
                return done();
            }
            const completeEndSession = () => {
                maybeClearPinnedConnection(this, finalOptions);
                const serverSession = this[kServerSession];
                if (serverSession != null) {
                    // release the server session back to the pool
                    this.sessionPool.release(serverSession);
                    // Make sure a new serverSession never makes it on to the ClientSession
                    Object.defineProperty(this, kServerSession, {
                        value: ServerSession.clone(serverSession)
                    });
                }
                // mark the session as ended, and emit a signal
                this.hasEnded = true;
                this.emit('ended', this);
                // spec indicates that we should ignore all errors for `endSessions`
                done();
            };
            if (this.inTransaction()) {
                // If we've reached endSession and the transaction is still active
                // by default we abort it
                this.abortTransaction(err => {
                    if (err)
                        return done(err);
                    completeEndSession();
                });
                return;
            }
            completeEndSession();
        });
    }
    /**
     * Advances the operationTime for a ClientSession.
     *
     * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to
     */
    advanceOperationTime(operationTime) {
        if (this.operationTime == null) {
            this.operationTime = operationTime;
            return;
        }
        if (operationTime.greaterThan(this.operationTime)) {
            this.operationTime = operationTime;
        }
    }
    /**
     * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession
     *
     * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature
     */
    advanceClusterTime(clusterTime) {
        var _b, _c;
        if (!clusterTime || typeof clusterTime !== 'object') {
            throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');
        }
        if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {
            throw new error_1.MongoInvalidArgumentError('input cluster time "clusterTime" property must be a valid BSON Timestamp');
        }
        if (!clusterTime.signature ||
            ((_b = clusterTime.signature.hash) === null || _b === void 0 ? void 0 : _b._bsontype) !== 'Binary' ||
            (typeof clusterTime.signature.keyId !== 'number' &&
                ((_c = clusterTime.signature.keyId) === null || _c === void 0 ? void 0 : _c._bsontype) !== 'Long') // apparently we decode the key to number?
        ) {
            throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid "signature" property with BSON Binary hash and BSON Long keyId');
        }
        (0, common_1._advanceClusterTime)(this, clusterTime);
    }
    /**
     * Used to determine if this session equals another
     *
     * @param session - The session to compare to
     */
    equals(session) {
        if (!(session instanceof ClientSession)) {
            return false;
        }
        if (this.id == null || session.id == null) {
            return false;
        }
        return this.id.id.buffer.equals(session.id.id.buffer);
    }
    /**
     * Increment the transaction number on the internal ServerSession
     *
     * @privateRemarks
     * This helper increments a value stored on the client session that will be
     * added to the serverSession's txnNumber upon applying it to a command.
     * This is because the serverSession is lazily acquired after a connection is obtained
     */
    incrementTransactionNumber() {
        this[kTxnNumberIncrement] += 1;
    }
    /** @returns whether this session is currently in a transaction or not */
    inTransaction() {
        return this.transaction.isActive;
    }
    /**
     * Starts a new transaction with the given options.
     *
     * @param options - Options for the transaction
     */
    startTransaction(options) {
        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (this[kSnapshotEnabled]) {
            throw new error_1.MongoCompatibilityError('Transactions are not allowed with snapshot sessions');
        }
        if (this.inTransaction()) {
            throw new error_1.MongoTransactionError('Transaction already in progress');
        }
        if (this.isPinned && this.transaction.isCommitted) {
            this.unpin();
        }
        const topologyMaxWireVersion = (0, utils_1.maxWireVersion)(this.client.topology);
        if ((0, shared_1.isSharded)(this.client.topology) &&
            topologyMaxWireVersion != null &&
            topologyMaxWireVersion < minWireVersionForShardedTransactions) {
            throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');
        }
        // increment txnNumber
        this.incrementTransactionNumber();
        // create transaction state
        this.transaction = new transactions_1.Transaction({
            readConcern: (_c = (_b = options === null || options === void 0 ? void 0 : options.readConcern) !== null && _b !== void 0 ? _b : this.defaultTransactionOptions.readConcern) !== null && _c !== void 0 ? _c : (_d = this.clientOptions) === null || _d === void 0 ? void 0 : _d.readConcern,
            writeConcern: (_f = (_e = options === null || options === void 0 ? void 0 : options.writeConcern) !== null && _e !== void 0 ? _e : this.defaultTransactionOptions.writeConcern) !== null && _f !== void 0 ? _f : (_g = this.clientOptions) === null || _g === void 0 ? void 0 : _g.writeConcern,
            readPreference: (_j = (_h = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _h !== void 0 ? _h : this.defaultTransactionOptions.readPreference) !== null && _j !== void 0 ? _j : (_k = this.clientOptions) === null || _k === void 0 ? void 0 : _k.readPreference,
            maxCommitTimeMS: (_l = options === null || options === void 0 ? void 0 : options.maxCommitTimeMS) !== null && _l !== void 0 ? _l : this.defaultTransactionOptions.maxCommitTimeMS
        });
        this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);
    }
    commitTransaction(callback) {
        return (0, utils_1.maybePromise)(callback, cb => endTransaction(this, 'commitTransaction', cb));
    }
    abortTransaction(callback) {
        return (0, utils_1.maybePromise)(callback, cb => endTransaction(this, 'abortTransaction', cb));
    }
    /**
     * This is here to ensure that ClientSession is never serialized to BSON.
     */
    toBSON() {
        throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');
    }
    /**
     * Runs a provided callback within a transaction, retrying either the commitTransaction operation
     * or entire transaction as needed (and when the error permits) to better ensure that
     * the transaction can complete successfully.
     *
     * **IMPORTANT:** This method requires the user to return a Promise, and `await` all operations.
     * Any callbacks that do not return a Promise will result in undefined behavior.
     *
     * @remarks
     * This function:
     * - Will return the command response from the final commitTransaction if every operation is successful (can be used as a truthy object)
     * - Will return `undefined` if the transaction is explicitly aborted with `await session.abortTransaction()`
     * - Will throw if one of the operations throws or `throw` statement is used inside the `withTransaction` callback
     *
     * Checkout a descriptive example here:
     * @see https://www.mongodb.com/developer/quickstart/node-transactions/
     *
     * @param fn - callback to run within a transaction
     * @param options - optional settings for the transaction
     * @returns A raw command response or undefined
     */
    withTransaction(fn, options) {
        const startTime = (0, utils_1.now)();
        return attemptTransaction(this, startTime, fn, options);
    }
}
exports.ClientSession = ClientSession;
_a = kSnapshotEnabled;
const MAX_WITH_TRANSACTION_TIMEOUT = 120000;
const NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([
    'CannotSatisfyWriteConcern',
    'UnknownReplWriteConcern',
    'UnsatisfiableWriteConcern'
]);
function hasNotTimedOut(startTime, max) {
    return (0, utils_1.calculateDurationInMs)(startTime) < max;
}
function isUnknownTransactionCommitResult(err) {
    const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError &&
        err.codeName &&
        NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);
    return (isMaxTimeMSExpiredError(err) ||
        (!isNonDeterministicWriteConcernError &&
            err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern &&
            err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern));
}
function maybeClearPinnedConnection(session, options) {
    // unpin a connection if it has been pinned
    const conn = session[kPinnedConnection];
    const error = options === null || options === void 0 ? void 0 : options.error;
    if (session.inTransaction() &&
        error &&
        error instanceof error_1.MongoError &&
        error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
        return;
    }
    const topology = session.client.topology;
    // NOTE: the spec talks about what to do on a network error only, but the tests seem to
    //       to validate that we don't unpin on _all_ errors?
    if (conn && topology != null) {
        const servers = Array.from(topology.s.servers.values());
        const loadBalancer = servers[0];
        if ((options === null || options === void 0 ? void 0 : options.error) == null || (options === null || options === void 0 ? void 0 : options.force)) {
            loadBalancer.s.pool.checkIn(conn);
            conn.emit(constants_1.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION
                ? metrics_1.ConnectionPoolMetrics.TXN
                : metrics_1.ConnectionPoolMetrics.CURSOR);
            if (options === null || options === void 0 ? void 0 : options.forceClear) {
                loadBalancer.s.pool.clear(conn.serviceId);
            }
        }
        session[kPinnedConnection] = undefined;
    }
}
exports.maybeClearPinnedConnection = maybeClearPinnedConnection;
function isMaxTimeMSExpiredError(err) {
    if (err == null || !(err instanceof error_1.MongoServerError)) {
        return false;
    }
    return (err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired ||
        (err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired));
}
function attemptTransactionCommit(session, startTime, fn, options) {
    return session.commitTransaction().catch((err) => {
        if (err instanceof error_1.MongoError &&
            hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) &&
            !isMaxTimeMSExpiredError(err)) {
            if (err.hasErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult)) {
                return attemptTransactionCommit(session, startTime, fn, options);
            }
            if (err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
                return attemptTransaction(session, startTime, fn, options);
            }
        }
        throw err;
    });
}
const USER_EXPLICIT_TXN_END_STATES = new Set([
    transactions_1.TxnState.NO_TRANSACTION,
    transactions_1.TxnState.TRANSACTION_COMMITTED,
    transactions_1.TxnState.TRANSACTION_ABORTED
]);
function userExplicitlyEndedTransaction(session) {
    return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);
}
function attemptTransaction(session, startTime, fn, options) {
    const Promise = promise_provider_1.PromiseProvider.get();
    session.startTransaction(options);
    let promise;
    try {
        promise = fn(session);
    }
    catch (err) {
        promise = Promise.reject(err);
    }
    if (!(0, utils_1.isPromiseLike)(promise)) {
        session.abortTransaction();
        throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');
    }
    return promise.then(() => {
        if (userExplicitlyEndedTransaction(session)) {
            return;
        }
        return attemptTransactionCommit(session, startTime, fn, options);
    }, err => {
        function maybeRetryOrThrow(err) {
            if (err instanceof error_1.MongoError &&
                err.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError) &&
                hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {
                return attemptTransaction(session, startTime, fn, options);
            }
            if (isMaxTimeMSExpiredError(err)) {
                err.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
            }
            throw err;
        }
        if (session.inTransaction()) {
            return session.abortTransaction().then(() => maybeRetryOrThrow(err));
        }
        return maybeRetryOrThrow(err);
    });
}
function endTransaction(session, commandName, callback) {
    // handle any initial problematic cases
    const txnState = session.transaction.state;
    if (txnState === transactions_1.TxnState.NO_TRANSACTION) {
        callback(new error_1.MongoTransactionError('No transaction started'));
        return;
    }
    if (commandName === 'commitTransaction') {
        if (txnState === transactions_1.TxnState.STARTING_TRANSACTION ||
            txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
            // the transaction was never started, we can safely exit here
            session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);
            callback();
            return;
        }
        if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {
            callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));
            return;
        }
    }
    else {
        if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {
            // the transaction was never started, we can safely exit here
            session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
            callback();
            return;
        }
        if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {
            callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));
            return;
        }
        if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED ||
            txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {
            callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));
            return;
        }
    }
    // construct and send the command
    const command = { [commandName]: 1 };
    // apply a writeConcern if specified
    let writeConcern;
    if (session.transaction.options.writeConcern) {
        writeConcern = Object.assign({}, session.transaction.options.writeConcern);
    }
    else if (session.clientOptions && session.clientOptions.writeConcern) {
        writeConcern = { w: session.clientOptions.writeConcern.w };
    }
    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {
        writeConcern = Object.assign({ wtimeout: 10000 }, writeConcern, { w: 'majority' });
    }
    if (writeConcern) {
        Object.assign(command, { writeConcern });
    }
    if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {
        Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });
    }
    function commandHandler(error, result) {
        if (commandName !== 'commitTransaction') {
            session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);
            if (session.loadBalanced) {
                maybeClearPinnedConnection(session, { force: false });
            }
            // The spec indicates that we should ignore all errors on `abortTransaction`
            return callback();
        }
        session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);
        if (error instanceof error_1.MongoError) {
            if (error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError) ||
                error instanceof error_1.MongoWriteConcernError ||
                isMaxTimeMSExpiredError(error)) {
                if (isUnknownTransactionCommitResult(error)) {
                    error.addErrorLabel(error_1.MongoErrorLabel.UnknownTransactionCommitResult);
                    // per txns spec, must unpin session in this case
                    session.unpin({ error });
                }
            }
            else if (error.hasErrorLabel(error_1.MongoErrorLabel.TransientTransactionError)) {
                session.unpin({ error });
            }
        }
        callback(error, result);
    }
    if (session.transaction.recoveryToken) {
        command.recoveryToken = session.transaction.recoveryToken;
    }
    // send the command
    (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {
        session,
        readPreference: read_preference_1.ReadPreference.primary,
        bypassPinningCheck: true
    }), (error, result) => {
        if (command.abortTransaction) {
            // always unpin on abort regardless of command outcome
            session.unpin();
        }
        if (error instanceof error_1.MongoError && error.hasErrorLabel(error_1.MongoErrorLabel.RetryableWriteError)) {
            // SPEC-1185: apply majority write concern when retrying commitTransaction
            if (command.commitTransaction) {
                // per txns spec, must unpin session in this case
                session.unpin({ force: true });
                command.writeConcern = Object.assign({ wtimeout: 10000 }, command.writeConcern, {
                    w: 'majority'
                });
            }
            return (0, execute_operation_1.executeOperation)(session.client, new run_command_1.RunAdminCommandOperation(undefined, command, {
                session,
                readPreference: read_preference_1.ReadPreference.primary,
                bypassPinningCheck: true
            }), commandHandler);
        }
        commandHandler(error, result);
    });
}
/**
 * Reflects the existence of a session on the server. Can be reused by the session pool.
 * WARNING: not meant to be instantiated directly. For internal use only.
 * @public
 */
class ServerSession {
    /** @internal */
    constructor() {
        this.id = { id: new bson_1.Binary((0, utils_1.uuidV4)(), bson_1.Binary.SUBTYPE_UUID) };
        this.lastUse = (0, utils_1.now)();
        this.txnNumber = 0;
        this.isDirty = false;
    }
    /**
     * Determines if the server session has timed out.
     *
     * @param sessionTimeoutMinutes - The server's "logicalSessionTimeoutMinutes"
     */
    hasTimedOut(sessionTimeoutMinutes) {
        // Take the difference of the lastUse timestamp and now, which will result in a value in
        // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`
        const idleTimeMinutes = Math.round((((0, utils_1.calculateDurationInMs)(this.lastUse) % 86400000) % 3600000) / 60000);
        return idleTimeMinutes > sessionTimeoutMinutes - 1;
    }
    /**
     * @internal
     * Cloning meant to keep a readable reference to the server session data
     * after ClientSession has ended
     */
    static clone(serverSession) {
        const arrayBuffer = new ArrayBuffer(16);
        const idBytes = Buffer.from(arrayBuffer);
        idBytes.set(serverSession.id.id.buffer);
        const id = new bson_1.Binary(idBytes, serverSession.id.id.sub_type);
        // Manual prototype construction to avoid modifying the constructor of this class
        return Object.setPrototypeOf({
            id: { id },
            lastUse: serverSession.lastUse,
            txnNumber: serverSession.txnNumber,
            isDirty: serverSession.isDirty
        }, ServerSession.prototype);
    }
}
exports.ServerSession = ServerSession;
/**
 * Maintains a pool of Server Sessions.
 * For internal use only
 * @internal
 */
class ServerSessionPool {
    constructor(topology) {
        if (topology == null) {
            throw new error_1.MongoRuntimeError('ServerSessionPool requires a topology');
        }
        this.topology = topology;
        this.sessions = [];
    }
    /** Ends all sessions in the session pool */
    endAllPooledSessions(callback) {
        if (this.sessions.length) {
            this.topology.endSessions(this.sessions.map((session) => session.id), () => {
                this.sessions = [];
                if (typeof callback === 'function') {
                    callback();
                }
            });
            return;
        }
        if (typeof callback === 'function') {
            callback();
        }
    }
    /**
     * Acquire a Server Session from the pool.
     * Iterates through each session in the pool, removing any stale sessions
     * along the way. The first non-stale session found is removed from the
     * pool and returned. If no non-stale session is found, a new ServerSession is created.
     */
    acquire() {
        const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes || 10;
        while (this.sessions.length) {
            const session = this.sessions.shift();
            if (session && (this.topology.loadBalanced || !session.hasTimedOut(sessionTimeoutMinutes))) {
                return session;
            }
        }
        return new ServerSession();
    }
    /**
     * Release a session to the session pool
     * Adds the session back to the session pool if the session has not timed out yet.
     * This method also removes any stale sessions from the pool.
     *
     * @param session - The session to release to the pool
     */
    release(session) {
        const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;
        if (this.topology.loadBalanced && !sessionTimeoutMinutes) {
            this.sessions.unshift(session);
        }
        if (!sessionTimeoutMinutes) {
            return;
        }
        while (this.sessions.length) {
            const pooledSession = this.sessions[this.sessions.length - 1];
            if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {
                this.sessions.pop();
            }
            else {
                break;
            }
        }
        if (!session.hasTimedOut(sessionTimeoutMinutes)) {
            if (session.isDirty) {
                return;
            }
            // otherwise, readd this session to the session pool
            this.sessions.unshift(session);
        }
    }
}
exports.ServerSessionPool = ServerSessionPool;
/**
 * Optionally decorate a command with sessions specific keys
 *
 * @param session - the session tracking transaction state
 * @param command - the command to decorate
 * @param options - Optional settings passed to calling operation
 *
 * @internal
 */
function applySession(session, command, options) {
    var _b, _c;
    if (session.hasEnded) {
        return new error_1.MongoExpiredSessionError();
    }
    // May acquire serverSession here
    const serverSession = session.serverSession;
    if (serverSession == null) {
        return new error_1.MongoRuntimeError('Unable to acquire server session');
    }
    if (((_b = options.writeConcern) === null || _b === void 0 ? void 0 : _b.w) === 0) {
        if (session && session.explicit) {
            // Error if user provided an explicit session to an unacknowledged write (SPEC-1019)
            return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');
        }
        return;
    }
    // mark the last use of this session, and apply the `lsid`
    serverSession.lastUse = (0, utils_1.now)();
    command.lsid = serverSession.id;
    const inTxnOrTxnCommand = session.inTransaction() || (0, transactions_1.isTransactionCommand)(command);
    const isRetryableWrite = !!options.willRetryWrite;
    if (isRetryableWrite || inTxnOrTxnCommand) {
        serverSession.txnNumber += session[kTxnNumberIncrement];
        session[kTxnNumberIncrement] = 0;
        command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);
    }
    if (!inTxnOrTxnCommand) {
        if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {
            session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);
        }
        if (session.supports.causalConsistency &&
            session.operationTime &&
            (0, utils_1.commandSupportsReadConcern)(command, options)) {
            command.readConcern = command.readConcern || {};
            Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        }
        else if (session[kSnapshotEnabled]) {
            command.readConcern = command.readConcern || { level: read_concern_1.ReadConcernLevel.snapshot };
            if (session[kSnapshotTime] != null) {
                Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });
            }
        }
        return;
    }
    // now attempt to apply transaction-specific sessions data
    // `autocommit` must always be false to differentiate from retryable writes
    command.autocommit = false;
    if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {
        session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);
        command.startTransaction = true;
        const readConcern = session.transaction.options.readConcern || ((_c = session === null || session === void 0 ? void 0 : session.clientOptions) === null || _c === void 0 ? void 0 : _c.readConcern);
        if (readConcern) {
            command.readConcern = readConcern;
        }
        if (session.supports.causalConsistency && session.operationTime) {
            command.readConcern = command.readConcern || {};
            Object.assign(command.readConcern, { afterClusterTime: session.operationTime });
        }
    }
    return;
}
exports.applySession = applySession;
function updateSessionFromResponse(session, document) {
    var _b;
    if (document.$clusterTime) {
        (0, common_1._advanceClusterTime)(session, document.$clusterTime);
    }
    if (document.operationTime && session && session.supports.causalConsistency) {
        session.advanceOperationTime(document.operationTime);
    }
    if (document.recoveryToken && session && session.inTransaction()) {
        session.transaction._recoveryToken = document.recoveryToken;
    }
    if ((session === null || session === void 0 ? void 0 : session[kSnapshotEnabled]) && session[kSnapshotTime] == null) {
        // find and aggregate commands return atClusterTime on the cursor
        // distinct includes it in the response body
        const atClusterTime = ((_b = document.cursor) === null || _b === void 0 ? void 0 : _b.atClusterTime) || document.atClusterTime;
        if (atClusterTime) {
            session[kSnapshotTime] = atClusterTime;
        }
    }
}
exports.updateSessionFromResponse = updateSessionFromResponse;
//# sourceMappingURL=sessions.js.map
